<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDRTrunk Transcriber - Dashboard</title>
    <style>
        :root {
            /* Light theme variables */
            --bg-color: #f5f5f5;
            --card-bg: white;
            --text-color: #2c3e50;
            --header-bg: #2c3e50;
            --header-text: white;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
            --border-color: #ddd;
            --transcription-bg: rgba(52, 152, 219, 0.1);
            --transcription-border: #3498db;
            --processing-bg: rgba(243, 156, 18, 0.1);
            --processing-border: #f39c12;
            --speaker-color: #3498db;
        }

        [data-theme="dark"] {
            /* Dark theme variables */
            --bg-color: #1a1a1a;
            --card-bg: #2d3748;
            --text-color: #e2e8f0;
            --header-bg: #1a202c;
            --header-text: #e2e8f0;
            --accent-color: #3182ce;
            --success-color: #38a169;
            --warning-color: #dd6b20;
            --error-color: #fc8181;
            --shadow: 0 2px 4px rgba(0,0,0,0.3);
            --border-color: #4a5568;
            --transcription-bg: rgba(49, 130, 206, 0.15);
            --transcription-border: #3182ce;
            --processing-bg: rgba(221, 107, 32, 0.15);
            --processing-border: #dd6b20;
            --speaker-color: #63b3ed;
        }

        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: var(--bg-color); color: var(--text-color); transition: all 0.3s ease; }
        .header { background: var(--header-bg); color: var(--header-text); padding: 1rem; margin: -20px -20px 20px; display: flex; justify-content: space-between; align-items: center; }
        .nav { display: flex; gap: 1rem; margin-top: 1rem; }
        .nav a { color: var(--header-text); text-decoration: none; padding: 0.5rem 1rem; border-radius: 4px; }
        .nav a:hover { background: rgba(255,255,255,0.1); }
        .theme-toggle { background: var(--accent-color); color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.9em; }
        .theme-toggle:hover { opacity: 0.8; }
        .dashboard-layout { display: flex; flex-direction: column; gap: 1rem; }
        .card { background: var(--card-bg); color: var(--text-color); padding: 1.5rem; border-radius: 8px; box-shadow: var(--shadow); }
        .card h3 { margin-top: 0; color: var(--text-color); }
        .status { padding: 1rem; background: var(--success-color); color: white; border-left: 4px solid var(--success-color); margin: 1rem 0; }

        /* Processing Queue Banner */
        .processing-queue { background: var(--processing-bg); border: 1px solid var(--processing-border); border-radius: 6px; padding: 0.75rem 1rem; margin-bottom: 1rem; cursor: pointer; transition: all 0.3s ease; }
        .processing-queue.empty { display: none; }
        .processing-queue-header { display: flex; justify-content: space-between; align-items: center; }
        .processing-queue-summary { font-size: 0.9em; color: var(--text-color); }
        .processing-queue-toggle { font-size: 0.8em; color: var(--accent-color); }
        .processing-queue-details { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; margin-top: 0; }
        .processing-queue.expanded .processing-queue-details { max-height: 500px; margin-top: 0.75rem; }
        .processing-queue.expanded .processing-queue-toggle::after { content: ' ▲'; }
        .processing-queue:not(.expanded) .processing-queue-toggle::after { content: ' ▼'; }
        .processing-item { background: var(--card-bg); padding: 0.5rem; margin: 0.25rem 0; border-radius: 4px; font-size: 0.85em; }

        /* Search and Filter Controls */
        .search-filter-bar { background: var(--card-bg); padding: 1rem; border-radius: 6px; margin-bottom: 1rem; box-shadow: var(--shadow); }
        .search-input { width: 100%; padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-color); color: var(--text-color); margin-bottom: 0.75rem; font-size: 0.95em; }
        .filter-controls { display: flex; gap: 0.5rem; flex-wrap: wrap; }
        .filter-select { padding: 0.4rem 0.75rem; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-color); color: var(--text-color); font-size: 0.85em; cursor: pointer; }
        .filter-select:hover { background: var(--accent-color); color: white; }

        /* Transcription Feed */
        .transcription-feed { background: var(--card-bg); border-radius: 8px; padding: 1.5rem; box-shadow: var(--shadow); }
        .transcription-feed h2 { margin-top: 0; color: var(--text-color); border-bottom: 2px solid var(--accent-color); padding-bottom: 0.5rem; }
        .feed-container { max-height: 70vh; overflow-y: auto; margin-top: 1rem; padding-right: 0.5rem; }
        .feed-container::-webkit-scrollbar { width: 8px; }
        .feed-container::-webkit-scrollbar-track { background: var(--bg-color); border-radius: 4px; }
        .feed-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        .feed-container::-webkit-scrollbar-thumb:hover { background: var(--accent-color); }
        .transcription-card { background: var(--card-bg); border-left: 4px solid var(--success-color); border-radius: 6px; padding: 1rem; margin-bottom: 1rem; box-shadow: var(--shadow); transition: transform 0.2s ease; }
        .transcription-card:hover { transform: translateX(4px); }
        .transcription-card.new { animation: slideIn 0.5s ease; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .transcription-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; flex-wrap: wrap; gap: 0.5rem; }
        .transcription-meta { font-size: 0.9em; color: var(--text-color); }
        .transcription-time { font-weight: bold; color: var(--accent-color); }
        .transcription-badges { display: flex; gap: 0.5rem; align-items: center; }
        .confidence-badge { background: var(--success-color); color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.75em; font-weight: bold; }
        .confidence-badge.medium { background: var(--warning-color); }
        .confidence-badge.low { background: var(--error-color); }
        .transcription-text { background: var(--transcription-bg); border-radius: 4px; padding: 0.75rem; border-left: 3px solid var(--transcription-border); font-family: monospace; font-size: 0.9em; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; }
        .speaker-label { color: var(--speaker-color); font-weight: bold; }
        .load-more-btn { width: 100%; padding: 0.75rem; background: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; margin-top: 1rem; transition: background 0.3s ease; }
        .load-more-btn:hover { opacity: 0.9; }
        .load-more-btn:disabled { background: var(--border-color); cursor: not-allowed; }
        .empty-state { text-align: center; padding: 3rem 1rem; color: var(--text-color); opacity: 0.7; }

        /* Stats Section */
        .dashboard-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; }
        @media (max-width: 768px) { .dashboard-stats { grid-template-columns: 1fr; } .filter-controls { flex-direction: column; } .transcription-header { flex-direction: column; align-items: flex-start; } }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1 style="margin: 0;">SDRTrunk Transcriber</h1>
            <nav class="nav">
                <a href="/">Dashboard</a>
                <a href="/calls">Calls</a>
                <a href="/stats">Statistics</a>
                <a href="/admin">Admin</a>
            </nav>
        </div>
        <button class="theme-toggle" onclick="toggleTheme()">🌙 Dark Mode</button>
    </div>

    <h2>Live Dashboard</h2>

    <div class="status">
        <strong>System Status:</strong> Online |
        <strong>API:</strong> Available |
        <strong>WhisperX:</strong> Connected
    </div>

    <div class="dashboard-layout">
        <!-- PROCESSING QUEUE BANNER (Collapsible) -->
        <div id="processing-queue" class="processing-queue empty" onclick="toggleProcessingQueue()">
            <div class="processing-queue-header">
                <div class="processing-queue-summary">
                    <span id="queue-summary">No calls processing</span>
                </div>
                <div class="processing-queue-toggle">Click to expand</div>
            </div>
            <div class="processing-queue-details" id="processing-queue-details">
                <!-- Processing items populated by JavaScript -->
            </div>
        </div>

        <!-- SEARCH AND FILTER BAR -->
        <div class="search-filter-bar">
            <input type="text" id="search-input" class="search-input" placeholder="Search transcriptions..." onkeyup="handleSearch()">
            <div class="filter-controls">
                <select id="system-filter" class="filter-select" onchange="handleFilter()">
                    <option value="">All Systems</option>
                </select>
                <select id="talkgroup-filter" class="filter-select" onchange="handleFilter()">
                    <option value="">All Talkgroups</option>
                </select>
                <input type="date" id="date-from" class="filter-select" onchange="handleFilter()">
                <input type="date" id="date-to" class="filter-select" onchange="handleFilter()">
                <button class="filter-select" onclick="clearFilters()">Clear Filters</button>
            </div>
        </div>

        <!-- TRANSCRIPTION FEED (Main Focus) -->
        <div class="transcription-feed">
            <h2>Transcriptions</h2>
            <div id="feed-container" class="feed-container">
                <div id="transcription-list">
                    <div class="empty-state">
                        <p>Loading transcriptions...</p>
                    </div>
                </div>
            </div>
            <button id="load-more-btn" class="load-more-btn" onclick="loadMoreTranscriptions()" style="display: none;">
                Load More
            </button>
        </div>

        <!-- SYSTEM STATISTICS (Bottom) -->
        <div class="dashboard-stats">
            <div class="card">
                <h3>System Statistics</h3>
                <p><strong>Total Calls:</strong> <span id="total-calls">Loading...</span></p>
                <p><strong>Calls Today:</strong> <span id="calls-today">Loading...</span></p>
                <p><strong>Transcribed:</strong> <span id="transcribed-count">0</span></p>
                <p><strong>Processing:</strong> <span id="processing-count">0</span></p>
            </div>

            <div class="card">
                <h3>System Health</h3>
                <p><strong>API Server:</strong> <span id="api-status">Loading...</span></p>
                <p><strong>Database:</strong> <span id="db-status">Loading...</span></p>
                <p><strong>WhisperX Service:</strong> <span id="whisperx-status">Loading...</span></p>
                <p><strong>Storage:</strong> <span id="storage-status">Available</span></p>
            </div>
        </div>
    </div>

    <script>
        // State management
        let completedTranscriptions = [];
        let processingCalls = [];
        let currentOffset = 0;
        let hasMoreTranscriptions = true;
        let isLoading = false;
        let renderedCallIds = new Set(); // Track which calls are already in the DOM
        let filters = {
            searchText: '',
            systemId: '',
            talkgroupId: '',
            dateFrom: '',
            dateTo: ''
        };

        const PAGE_SIZE = 20;

        // Load completed transcriptions
        async function loadCompletedTranscriptions(reset = false) {
            if (isLoading || (!hasMoreTranscriptions && !reset)) return;

            isLoading = true;
            updateLoadMoreButton(); // Show "Loading..." on button

            if (reset) {
                currentOffset = 0;
                completedTranscriptions = [];
                // Show loading state
                document.getElementById('transcription-list').innerHTML = '<div class="empty-state"><p>Loading transcriptions...</p></div>';
            }

            try {
                // Build query parameters
                let params = new URLSearchParams({
                    limit: PAGE_SIZE,
                    offset: currentOffset,
                    include_transcription: 'true',
                    sort: 'desc'
                });

                // Add filters
                if (filters.systemId) params.append('system_id', filters.systemId);
                if (filters.talkgroupId) params.append('talkgroup_id', filters.talkgroupId);
                if (filters.dateFrom) params.append('from_date', new Date(filters.dateFrom).toISOString());
                if (filters.dateTo) params.append('to_date', new Date(filters.dateTo).toISOString());

                const response = await fetch(`/api/calls?${params}`, {
                    signal: AbortSignal.timeout(10000) // 10 second timeout
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Completed transcriptions loaded:', data);

                if (data.calls) {
                    // Filter for completed transcriptions only
                    const completed = data.calls.filter(call =>
                        call.transcription_status === 'completed' && call.transcription_text
                    );

                    if (reset) {
                        completedTranscriptions = completed;
                    } else {
                        completedTranscriptions = completedTranscriptions.concat(completed);
                    }

                    hasMoreTranscriptions = data.pagination?.has_next || false;
                    currentOffset += PAGE_SIZE;

                    renderTranscriptions();
                    updateLoadMoreButton();
                }
            } catch (error) {
                console.error('Failed to load transcriptions:', error);
                const container = document.getElementById('transcription-list');
                if (completedTranscriptions.length === 0) {
                    container.innerHTML = `<div class="empty-state"><p>Error loading transcriptions. <button onclick="loadCompletedTranscriptions(true)" style="background: var(--accent-color); color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">Retry</button></p></div>`;
                }
            } finally {
                isLoading = false;
                updateLoadMoreButton(); // Update button state
            }
        }

        // Load processing/pending calls
        async function loadProcessingQueue() {
            try {
                const response = await fetch('/api/calls?limit=20&sort=desc');
                const data = await response.json();

                if (data.calls) {
                    // Filter for non-completed calls
                    processingCalls = data.calls.filter(call =>
                        call.transcription_status !== 'completed'
                    );

                    renderProcessingQueue();
                    updateProcessingCount();
                }
            } catch (error) {
                console.error('Failed to load processing queue:', error);
            }
        }

        // Load dashboard statistics
        async function loadDashboardStats() {
            try {
                const statsResponse = await fetch('/api/stats/global');
                const statsData = await statsResponse.json();
                console.log('Stats API response:', statsData);

                if (!statsData.error) {
                    document.getElementById('calls-today').textContent = statsData.calls_last_24h || '0';
                    document.getElementById('total-calls').textContent = statsData.total_calls || '0';
                    document.getElementById('transcribed-count').textContent = completedTranscriptions.length;
                    updateSystemStatus();
                }
            } catch (error) {
                console.error('Failed to load stats:', error);
            }
        }

        // Render transcription cards
        function renderTranscriptions(incrementalOnly = false) {
            const container = document.getElementById('transcription-list');

            // Apply search filter
            let filtered = completedTranscriptions;
            if (filters.searchText) {
                const searchLower = filters.searchText.toLowerCase();
                filtered = filtered.filter(call =>
                    call.transcription_text?.toLowerCase().includes(searchLower) ||
                    call.system_id?.toLowerCase().includes(searchLower) ||
                    call.talkgroup_label?.toLowerCase().includes(searchLower)
                );
            }

            // Incremental mode: only add NEW calls
            if (incrementalOnly) {
                const newCalls = filtered.filter(call => !renderedCallIds.has(call.id));
                if (newCalls.length === 0) return;

                // Generate HTML only for new calls
                const html = newCalls.map(call => generateTranscriptionCard(call)).join('');

                // Prepend to container (newest first)
                container.insertAdjacentHTML('afterbegin', html);

                // Mark as rendered
                newCalls.forEach(call => renderedCallIds.add(call.id));
                return;
            }

            // Full render mode: replace everything (for filters, initial load)
            renderedCallIds.clear();

            if (filtered.length === 0) {
                // Distinguish between loading, filtered out, and truly empty
                if (isLoading && completedTranscriptions.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>Loading transcriptions...</p></div>';
                } else if (filters.searchText && completedTranscriptions.length > 0) {
                    container.innerHTML = '<div class="empty-state"><p>No transcriptions match your search.</p></div>';
                } else if (completedTranscriptions.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>No completed transcriptions yet.<br><small>Transcriptions will appear here as calls are processed.</small></p></div>';
                } else {
                    container.innerHTML = '<div class="empty-state"><p>No transcriptions match the filters.</p></div>';
                }
                return;
            }

            const html = filtered.map(call => generateTranscriptionCard(call)).join('');
            container.innerHTML = html;

            // Mark all as rendered
            filtered.forEach(call => renderedCallIds.add(call.id));
        }

        // Generate HTML for a single transcription card
        function generateTranscriptionCard(call) {
            const time = new Date(call.call_timestamp).toLocaleString();
            const system = call.system_label || call.system_id || 'Unknown';
            const talkgroup = call.talkgroup_label || (call.talkgroup_id ? `TG${call.talkgroup_id}` : 'Unknown');
            const duration = call.duration_seconds ? `${parseFloat(call.duration_seconds).toFixed(1)}s` : 'N/A';

            // Confidence badge
            let confidenceHtml = '';
            if (call.transcription_confidence) {
                const confidence = parseFloat(call.transcription_confidence);
                const percentage = Math.round(confidence * 100);
                const badgeClass = percentage > 80 ? '' : percentage > 50 ? 'medium' : 'low';
                confidenceHtml = `<span class="confidence-badge ${badgeClass}">${percentage}%</span>`;
            }

            // Format transcription text with speaker labels
            let text = call.transcription_text || '';
            text = text.replace(/SPEAKER_(\d+):/g, '<br><span class="speaker-label">Speaker $1:</span>');
            text = text.replace(/^<br>/, '');

            return `
                <div class="transcription-card" data-call-id="${call.id}">
                    <div class="transcription-header">
                        <div class="transcription-meta">
                            <span class="transcription-time">${time}</span>
                            <span> • ${system}</span>
                            <span> • ${talkgroup}</span>
                            <span> • ${duration}</span>
                        </div>
                        <div class="transcription-badges">
                            ${confidenceHtml}
                        </div>
                    </div>
                    <div class="transcription-text">${text}</div>
                </div>
            `;
        }

        // Render processing queue
        function renderProcessingQueue() {
            const queueEl = document.getElementById('processing-queue');
            const detailsEl = document.getElementById('processing-queue-details');
            const summaryEl = document.getElementById('queue-summary');

            if (processingCalls.length === 0) {
                queueEl.classList.add('empty');
                summaryEl.textContent = 'No calls processing';
                return;
            }

            queueEl.classList.remove('empty');

            const processingCount = processingCalls.filter(c => c.transcription_status === 'processing').length;
            const pendingCount = processingCalls.filter(c => c.transcription_status === 'pending').length;

            summaryEl.innerHTML = `
                ${processingCount > 0 ? `<strong>${processingCount}</strong> processing` : ''}
                ${processingCount > 0 && pendingCount > 0 ? ' • ' : ''}
                ${pendingCount > 0 ? `<strong>${pendingCount}</strong> pending` : ''}
            `;

            const detailsHtml = processingCalls.map(call => {
                const time = new Date(call.call_timestamp).toLocaleString();
                const system = call.system_label || call.system_id || 'Unknown';
                const talkgroup = call.talkgroup_label || (call.talkgroup_id ? `TG${call.talkgroup_id}` : 'Unknown');
                const status = call.transcription_status || 'pending';

                return `
                    <div class="processing-item">
                        <strong>${time}</strong> - ${system} - ${talkgroup}
                        <span style="float: right; color: var(--warning-color);">${status}</span>
                    </div>
                `;
            }).join('');

            detailsEl.innerHTML = detailsHtml;
        }

        // Toggle processing queue expansion
        function toggleProcessingQueue() {
            const queueEl = document.getElementById('processing-queue');
            queueEl.classList.toggle('expanded');
        }

        // Update load more button
        function updateLoadMoreButton() {
            const btn = document.getElementById('load-more-btn');
            if (hasMoreTranscriptions && completedTranscriptions.length > 0) {
                btn.style.display = 'block';
                btn.disabled = isLoading;
                btn.textContent = isLoading ? 'Loading...' : 'Load More';
            } else {
                btn.style.display = 'none';
            }
        }

        // Load more transcriptions
        function loadMoreTranscriptions() {
            loadCompletedTranscriptions(false);
        }

        // Update processing count in stats
        function updateProcessingCount() {
            document.getElementById('processing-count').textContent = processingCalls.length;
        }

        // System status
        function updateSystemStatus() {
            document.getElementById('api-status').textContent = 'Online';
            document.getElementById('db-status').textContent = 'Connected';
            document.getElementById('whisperx-status').textContent = processingCalls.length > 0 ? 'Processing' : 'Idle';
            document.getElementById('storage-status').textContent = 'Available';
        }

        // Search handler (debounced)
        let searchTimeout;
        function handleSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filters.searchText = document.getElementById('search-input').value;
                renderTranscriptions();
            }, 300);
        }

        // Filter handler
        function handleFilter() {
            filters.systemId = document.getElementById('system-filter').value;
            filters.talkgroupId = document.getElementById('talkgroup-filter').value;
            filters.dateFrom = document.getElementById('date-from').value;
            filters.dateTo = document.getElementById('date-to').value;

            // Reload transcriptions with new filters
            loadCompletedTranscriptions(true);
        }

        // Clear filters
        function clearFilters() {
            document.getElementById('search-input').value = '';
            document.getElementById('system-filter').value = '';
            document.getElementById('talkgroup-filter').value = '';
            document.getElementById('date-from').value = '';
            document.getElementById('date-to').value = '';

            filters = {
                searchText: '',
                systemId: '',
                talkgroupId: '',
                dateFrom: '',
                dateTo: ''
            };

            loadCompletedTranscriptions(true);
        }

        // Populate filter dropdowns (smart update - preserve selections)
        let lastSystemOptions = '';
        let lastTalkgroupOptions = '';

        function populateFilters() {
            const systems = new Set();
            const talkgroups = new Set();

            completedTranscriptions.forEach(call => {
                if (call.system_id) systems.add(JSON.stringify({ id: call.system_id, label: call.system_label || call.system_id }));
                if (call.talkgroup_id) talkgroups.add(JSON.stringify({ id: call.talkgroup_id, label: call.talkgroup_label || `TG${call.talkgroup_id}` }));
            });

            const systemFilter = document.getElementById('system-filter');
            const talkgroupFilter = document.getElementById('talkgroup-filter');

            // Save current selections
            const currentSystemValue = systemFilter.value;
            const currentTalkgroupValue = talkgroupFilter.value;

            // Generate new option HTML
            let systemOptionsHtml = '<option value="">All Systems</option>';
            Array.from(systems).sort().forEach(item => {
                const { id, label } = JSON.parse(item);
                systemOptionsHtml += `<option value="${id}">${label}</option>`;
            });

            let talkgroupOptionsHtml = '<option value="">All Talkgroups</option>';
            Array.from(talkgroups).sort().forEach(item => {
                const { id, label } = JSON.parse(item);
                talkgroupOptionsHtml += `<option value="${id}">${label}</option>`;
            });

            // Only update if options changed
            if (systemOptionsHtml !== lastSystemOptions) {
                systemFilter.innerHTML = systemOptionsHtml;
                systemFilter.value = currentSystemValue; // Restore selection
                lastSystemOptions = systemOptionsHtml;
            }

            if (talkgroupOptionsHtml !== lastTalkgroupOptions) {
                talkgroupFilter.innerHTML = talkgroupOptionsHtml;
                talkgroupFilter.value = currentTalkgroupValue; // Restore selection
                lastTalkgroupOptions = talkgroupOptionsHtml;
            }
        }

        // Theme management
        function toggleTheme() {
            const body = document.body;
            const button = document.querySelector('.theme-toggle');
            const currentTheme = body.getAttribute('data-theme');

            if (currentTheme === 'dark') {
                body.removeAttribute('data-theme');
                button.textContent = '🌙 Dark Mode';
                localStorage.setItem('theme', 'light');
            } else {
                body.setAttribute('data-theme', 'dark');
                button.textContent = '☀️ Light Mode';
                localStorage.setItem('theme', 'dark');
            }
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const body = document.body;
            const button = document.querySelector('.theme-toggle');

            if (savedTheme === 'dark') {
                body.setAttribute('data-theme', 'dark');
                button.textContent = '☀️ Light Mode';
            }
        }


        // WebSocket connection for real-time updates
        let ws = null;

        function connectWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}/ws`;

            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('WebSocket connected');
            };

            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                } catch (error) {
                    console.error('Failed to parse WebSocket message:', error);
                }
            };

            ws.onclose = function() {
                console.log('WebSocket disconnected, attempting to reconnect...');
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }

        // Debounce timer for WebSocket updates
        let wsUpdateDebounce = null;
        let pendingCompletedCalls = new Set();

        function handleWebSocketMessage(message) {
            console.log('WebSocket message:', message);

            if (message.type === 'call_update') {
                const callId = message.call_id;
                const status = message.status;

                // Check if call moved from processing to completed
                if (status === 'Completed' || status === 'completed') {
                    // Remove from processing queue
                    processingCalls = processingCalls.filter(c => c.id !== callId);
                    renderProcessingQueue();
                    updateProcessingCount();

                    // Add to pending completions for batched fetch
                    pendingCompletedCalls.add(callId);

                    // Debounce: wait 2 seconds before fetching new completions
                    clearTimeout(wsUpdateDebounce);
                    wsUpdateDebounce = setTimeout(() => {
                        fetchCompletedCalls(Array.from(pendingCompletedCalls));
                        pendingCompletedCalls.clear();
                    }, 2000);
                }
            } else if (message.type === 'new_call') {
                // Add to processing queue
                const call = message.call;
                if (call && call.transcription_status !== 'completed') {
                    processingCalls.unshift(call);
                    renderProcessingQueue();
                    updateProcessingCount();
                }
            } else if (message.type === 'calls_update') {
                // Handle periodic bulk updates INCREMENTALLY (no scroll reset)
                handleBulkCallsUpdate(message.data);
            }
        }

        // Handle bulk calls update without resetting scroll
        function handleBulkCallsUpdate(data) {
            if (!data || !data.calls) return;

            const incomingCalls = data.calls;

            // Separate completed and processing calls
            const incomingCompleted = incomingCalls.filter(call =>
                call.transcription_status === 'completed' && call.transcription_text
            );
            const incomingProcessing = incomingCalls.filter(call =>
                call.transcription_status !== 'completed'
            );

            // Find NEW completed calls (not already in our list)
            const existingIds = new Set(completedTranscriptions.map(c => c.id));
            const newCompleted = incomingCompleted.filter(call => !existingIds.has(call.id));

            if (newCompleted.length > 0) {
                // Prepend new calls (newest first)
                completedTranscriptions.unshift(...newCompleted);

                // Incremental render - only add new cards
                renderTranscriptions(true);
                updateLoadMoreButton();
                populateFilters();
            }

            // Update processing queue
            processingCalls = incomingProcessing;
            renderProcessingQueue();
            updateProcessingCount();

            // Update stats
            loadDashboardStats();
        }

        // Fetch specific completed calls and prepend to list
        async function fetchCompletedCalls(callIds) {
            try {
                for (const callId of callIds) {
                    const response = await fetch(`/api/calls/${callId}`);
                    if (!response.ok) continue;

                    const callDetail = await response.json();

                    // Only add if it has transcription text and not already in list
                    if (callDetail.transcription_text &&
                        !completedTranscriptions.some(c => c.id === callDetail.id)) {
                        // Convert CallDetail to CallSummary format
                        const summary = {
                            id: callDetail.id,
                            call_timestamp: callDetail.call_timestamp,
                            system_id: callDetail.system_id,
                            system_label: callDetail.system_label,
                            talkgroup_id: callDetail.talkgroup_id,
                            talkgroup_label: callDetail.talkgroup_label,
                            talkgroup_group: callDetail.talkgroup_group,
                            talkgroup_tag: callDetail.talkgroup_tag,
                            source_radio_id: callDetail.source_radio_id,
                            talker_alias: callDetail.talker_alias,
                            audio_filename: callDetail.audio_filename,
                            audio_size_bytes: callDetail.audio_size_bytes,
                            duration_seconds: callDetail.duration_seconds,
                            transcription_status: callDetail.transcription_status,
                            transcription_confidence: callDetail.transcription_confidence,
                            transcription_text: callDetail.transcription_text,
                            frequency: callDetail.frequency
                        };

                        // Prepend to list (newest first)
                        completedTranscriptions.unshift(summary);
                    }
                }

                // Incremental render - only add new cards
                renderTranscriptions(true);
                updateLoadMoreButton();
                populateFilters();
                loadDashboardStats();
            } catch (error) {
                console.error('Failed to fetch completed calls:', error);
            }
        }

        // Initialize dashboard
        async function initDashboard() {
            loadTheme();

            // Load all data streams
            await Promise.all([
                loadCompletedTranscriptions(true),
                loadProcessingQueue(),
                loadDashboardStats()
            ]);

            // Populate filter dropdowns after initial load
            populateFilters();

            // Connect WebSocket for real-time updates
            connectWebSocket();
        }

        // Start the dashboard
        initDashboard();
    </script>
</body>
</html>